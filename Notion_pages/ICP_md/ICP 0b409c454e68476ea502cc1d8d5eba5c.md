# ICP

> ***오늘의 발표***

- ICP 이론 : Swimming 🏊‍♀️
- 코드 구현 : StrongPine 🌲

## ICP가 풀고자 하는 것

1. **R**otation and **t**ranslation matrix
2. **C**orrespondence

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled.png)

> **Assumption**: 가장 가까운 지점이 correspondence일 것이다.

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%201.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%201.png)

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%202.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%202.png)

*Slides from..* 

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%203.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%203.png)

---

### Least-Squares Fitting of Two 3-D Point Sets

- 우리가 풀고자 하는 문제는 이러한 상황에서 `Least Square`를 통해 `sigma`를 최소화시키는 R,t를 찾는 것 입니다.

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%204.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%204.png)

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%205.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%205.png)

- 음... 3개 항이 있는데요 항 하나를 제거할 수는 없을까요??

> Translation term을 제거하기 위해 **centroid** 개념을 도입

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%206.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%206.png)

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%207.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%207.png)

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%208.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%208.png)

중심을 기준으로는 같은 차이!!

좋습니다 😉 그럼 이제 이 식을 전개해봅니다.

- sigma를 최소화 하기 위해서는 마지막 차분 항이 최대가 되어야겠네요!! 이를 위한 R값을 구해봅시다.

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%209.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%209.png)

- 어떤 R이 이 값을 최대로 만들까요??

---

### 👦 우리 나름대로의 해석!

R은 어떤 행렬일까요?

1. 행렬곱은 기하학적으로 **내적**의 의미를 가집니다.
2. 내적을 최대로 만드는 theta 값은??

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2010.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2010.png)

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2011.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2011.png)

우리가 찾고자 하는 R은 두 point cloud들 사이의 `Rotation Matrix`가 입니다.

### 그럼 이걸 어떻게 찾죠 ❓❓

- Least Square Problem
- SVD & Pseudo inverse

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2012.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2012.png)

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2013.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2013.png)

- 우리의 경우

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2014.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2014.png)

*image from : [http://blog.naver.com/infoefficien/220790846543](http://blog.naver.com/infoefficien/220790846543)*

> H inverse가 없으면...? ⇒ `SVD` ⇒ `Pseudo Inverse`

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2015.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2015.png)

*image from : [https://angeloyeo.github.io/2019/08/01/SVD.html](https://angeloyeo.github.io/2019/08/01/SVD.html)*

- R은 회전 행렬이기 때문에 **Σ = I**

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2016.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2016.png)

**Exception** : **determinant**가 -1인 경우 (크기는 같지만, 방향이 반대)

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2017.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2017.png)

### translation은요 ❓❓

`centroid`의 차이로 계산!!

[ClayFlannigan/icp](https://github.com/ClayFlannigan/icp/blob/master/icp.py)

```python
def best_fit_transform(A, B):
    '''
    Calculates the least-squares best-fit transform that maps corresponding points A to B in m spatial dimensions
    Input:
      A: Nxm numpy array of corresponding points
      B: Nxm numpy array of corresponding points
    Returns:
      T: (m+1)x(m+1) homogeneous transformation matrix that maps A on to B
      R: mxm rotation matrix
      t: mx1 translation vector
    '''

    assert A.shape == B.shape

    # get number of dimensions
    m = A.shape[1]

    # translate points to their centroids
    centroid_A = np.mean(A, axis=0)
    centroid_B = np.mean(B, axis=0)
    AA = A - centroid_A
    BB = B - centroid_B

    # rotation matrix
    H = np.dot(AA.T, BB)
    U, S, Vt = np.linalg.svd(H)
    R = np.dot(Vt.T, U.T)

    # special reflection case
    if np.linalg.det(R) < 0:
       Vt[m-1,:] *= -1
       R = np.dot(Vt.T, U.T)

    # translation
    t = centroid_B.T - np.dot(R,centroid_A.T)

    # homogeneous transformation
    T = np.identity(m+1)
    T[:m, :m] = R
    T[:m, m] = t

**    return T, R, t
```

### **C**orrespondence는요 ❓❓

- In real Lidar SLAM...

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2018.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2018.png)

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2019.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2019.png)

slides from : [http://www2.informatik.uni-freiburg.de/~stachnis/pdf/rbpf-slam-tutorial-2007.pdf](http://www2.informatik.uni-freiburg.de/~stachnis/pdf/rbpf-slam-tutorial-2007.pdf)

***homogeneous transformation*** 이란?

![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2020.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2020.png)

**T**ranslation과 **R**otation을 

1. 하나의 행렬로 
2. Linear 연산으로 표현하기 위해

***Homogeneous transformation***을 사용합니다.

### Paper

---

[icp.pdf](ICP%200b409c454e68476ea502cc1d8d5eba5c/icp.pdf)

- 그럼... 드디어....

    ## 한솔님과 함께하는 즐거운 코딩 시간🏄‍♂️

    ![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2021.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2021.png)

    ![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2022.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2022.png)

    ![ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2023.png](ICP%200b409c454e68476ea502cc1d8d5eba5c/Untitled%2023.png)